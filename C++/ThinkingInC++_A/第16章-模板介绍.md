# 第16章 模板介绍

>继承和组合提供了重用对象代码的方法，C++模板特征提供了重用源代码的方法

## 16.1 容器

## 16.1.1 容器的需求

## 16.2 模板综述

>三种方法：

>>C方法：拷贝源码手工修改

>>smalltalk方法：继承基类object，或者多重继承进行多种层次结构的适用。较为复杂

>>C++模板

### 16.2.1 模板方法

>容器不再存放成为Object的通用基类，而是存放一个未指明的参数。当用户适用模板时，参数由编译器来替换。

## 16.3 模板语法

>template，指明会有一个或多个未指明的参数，当适用该类时，必须指定这些类型以使得编译器能够替换他们。

>Array<int> ia; Array<float> fa; 编译器会两次扩展Array模板，创建两个新的生成类。

### 16.3.1 非内联函数定义

>定义为非内联函数时，仍然需要将template<class T>放于函数定义的上方，明确指定给该函数内部使用。

#### 16.3.1.1 头文件

>头文件中不推荐存放任何会分配存储空间的任何东西。

>template<...>之后的任何东西都意味着编译器不会在编译当时给他分配空间。

>编译器和连接器有机制能去掉同一模板的多重定义。

#### 16.3.1.2 作为模板的IntStack

#### 16.3.1.3 模板中的常量

>template<class T, int size = 200>

## 16.4 作为模板的Stash和Stack

### 16.4.1 模板化的指针Stash

## 16.5 打开和关闭所有权

## 16.6 以值存放对象

## 16.7 迭代器简介

### 16.7.1 带有迭代器的stack

### 16.7.2 带有迭代器的pstash

## 16.8 为什么使用迭代器

### 16.8.1 函数模板






























