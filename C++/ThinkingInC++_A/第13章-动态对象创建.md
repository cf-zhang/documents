# 第13章 动态对象创建

>在C++对象创建时候既需要内存分配又需要初始化

>malloc 和 free只能完成内存分配

>new 和 delete弥补了malloc和free不足

## 13.1 对象创建 

>当创建一个C++对象的时候，会发生两件事

>>为对象分配内存

>>调用构造函数初始化那个内存

### 13.1.1 C从堆中获取存储单元的方法

>Obj *obj = (Obj*)malloc(sizeof(Obj));

> obj->init();

>步骤多，容易遗忘，类型检查严格，容易造成编译不过

### 13.1.2 operator new

>先申请内存，检查内存，调用构造函数初始化内存

>MyType *fp = new MyType(1,2);

>MyType *fp = new MyType;

### 13.1.3 operator delete

>先调用析构函数，释放内存

>推荐删除对象指针之后，赋值该指针为0或者nullptr，避免delete多次

### 13.1.4 一个简单的例子

>声明为友元后，在类内定义，会使得该函数为全局内联函数

### 13.1.5 内存管理的开销

### 13.2.1 使用delete void*可能会出错

>delete void*会释放这个对象的内存，但是并不会调用这个对象的构造函数，如果在这个类内有成员指针并为其分配了

内存，这块内存就会被泄露掉了。

### 13.2.2 对指针的清除责任

### 13.2.3 指针的Stash

#### 13.2.3.1 一个测试程序

## 13.3 用于数组的new和delete

>需要有一个默认构造函数

>MyType *fp = new MyType[100];

>delete [] fp

>如果使用delete fp，那么会造成99个MyType的内存无法回收

### 13.3.1 使指针更像数组

>int const *q = new int[10];/ const int *q = new int[10];

>int *const q = new int[10];

## 13.4 内存耗尽






## 13.2 重新设计前面的例子

## 13.3 对于数组的new和delete

## 13.4 耗尽内存

## 13.5 重载new和delete

