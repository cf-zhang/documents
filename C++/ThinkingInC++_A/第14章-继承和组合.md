# 第14章 继承和组合

>在新类中创建已存在的类的对象-组合

>在一个类的基础上增加一些新特性-继承

## 14.1 组合语法

## 14.2 继承语法


```
 #include <iostream>
 #include <vector>
 #include <new>
using namespace std;

class X{
    int i;
public:
    X(){i=0;}
    void set(int ii){ i = ii;}
    int read()const{return i;}
    int permute(){return i = i*47;}
};

class Y :public X{
    int i;
public:
    Y(){i=0;}
    int change(){
        i = permute();
        return i;
    }
    int readY(){return i;}
    void set(int ii){
        i = ii;
        X::set(ii+1);
    }
};

int main() {
    cout<<"sizeof(X) = "<<sizeof(X)<<endl;
    cout<<"sizeof(Y) = "<<sizeof(Y)<<endl;
    Y D;
    D.change();
    D.permute();
    D.set(12);
    cout<<D.read()<<endl;
    cout<<D.readY()<<endl;
    return 0;
}
```

## 14.3 构造函数的初始化表达式表

MyType::MyType(int i) : Bar(i）{}

### 14.3.1 成员对象初始化

>对于组合，也可以使用同样语法，只是使用的是对象的名字，而不是类名

### 14.3.2 在初始化表达式表中的内部类型

>所有对象的构造会发生在进入该类构造函数的左括号进入之前

>内部类型也可以用相同的语法进行初始化，但是并没有强制要求在左括号之前必须初始化

## 14.4 组合和继承的联合

>自动析构函数调用：继承关系会自动递归调用，成员对象如果不指明必须调用父类析构，则只会调用自身的析构

### 14.4.1 构造函数和析构函数调用的次序

>基类优先

>成员对象按照类中声明顺序，与初始化表没关系

## 14.5 名字隐藏

>重定义：普通成员函数，返回值与参数类型一致

>重写： 除了重定义的要求以外，会还应该是虚函数

>有重载成员函数的基类，如果在子类中有其中的一个或者几个重载的函数重新定义，那么在子类中只能使用被重载的那几个函数

>函数名字与基类一致，但是返回值或者参数类型发生了变化，那么就会对基类中的函数进行了隐藏

## 14.6 非自动继承的函数

>构造函数和析构函数不能被继承

>operator = 不能被继承

### 14.6.1 继承和静态成员函数

>静态与非静态成员函数共同点：

>>均可以被继承到派生类中

>>重新定义一个静态函数，所有在基类中的其他重载函数会被隐藏

>>改变一个静态函数特征，所有基类中的重载都会被隐藏

>静态成员函数不可以是虚函数

## 14.7 组合与继承的选择

>is-a

>has-a

### 14.7.1 子类型设置

### 14.7.2 私有继承

>不能理解私有继承有什么用：产生像基类接口一样的接口部分，而不允许该对象的处理像一个基类对象

#### 14.7.2.1 对私有继承成员公有化

```
#include <iostream>
#include <vector>
#include <new>
using namespace std;

class Pet
{
public:
    char eat()const {return 'a';}
    int speak()const {return 2;}
    float sleep()const {return 3.0;}
    float sleep(int)const{return 4.9;}
};
class Goldfish:Pet
{
public:
    using Pet::eat;
    using Pet::sleep;
};
int main() {
    Goldfish bob;
    bob.eat();
    bob.sleep();
    bob.sleep(1);
    return 0;
}
```

>给出一个重载函数的名字，会使得基类中所有它的重载版本公有化

## 14.8 protected

>protect对外部隐藏，对派生类开放

>最好让数据成员是private，因为我们应该保留改变内部实现的权利。通过protected成员函数控制对该类的继承者的访问

### 14.8.1 protected继承

## 14.9 运算符的重载与继承

>除赋值运算符外，其余运算符可以自动的继承到派生类中

## 14.10 多重继承

>多重继承会引起很多含糊的可能性

## 14.11 渐增式开发

## 14.12 向上类型转换

>新类属于原有类的类型

>将子类的引用或指针转变成父类的引用或指针被称为向上类型转换

### 14.12.1 为什么要“向上类型转换”
 
>从更专门的类型转换到更一般的类型

### 14.12.2 向上类型转换和拷贝构造函数

>如果允许编译器为派生类生成拷贝构造函数，它将首先自动的调用基类的拷贝狗杂函数，然后再是各成员对象的拷贝构造函数

### 14.12.3 组合与继承（再论）

>确定应当用组合还是用继承，最清楚的方法之一是询问是否需要从新类向上类型转换。

### 14.12.4 指针和引用的向上类型转换

>指针、引用

>函数调用

>赋值

### 14.12.5 危机

>当强制类型转换之后，对于内部成员函数的调用会使用父类的成员函数

>使用virtual声明之后可以解决上述问题


















































