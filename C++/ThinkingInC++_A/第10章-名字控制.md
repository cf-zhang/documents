# 第10章 名字控制
## 10.1 来自C语言的静态元素

>1.静态数据区

>2.控制名字的可见性

### 10.1.1 函数内部的静态变量

#### 10.1.1.1 函数内部的静态对象

>静态变量可以默认初始化，静态对象必须由相应的构造函数

#### 10.1.1.2 静态对象的析构函数

>在main退出之后会按照反向的顺序调用所有构造过的静态对象的析构函数

### 10.1.2 控制连接

>static修饰的变量，对象，函数只有在当前文件内部可见，链接。

>如果是定义在头文件里面，那么包含该头文件的源文件会单独课件该单元

>常量在C++中默认是内部可见的，在C中是全局可见（需要明确用extern标识）

#### 10.1.2.1 冲突问题

>函数内部用extern修饰的变量，会从外部链接中去寻找该地址去链接

>static 与 extern

### 10.1.3 其他存储类型说明符

>auto 默认就是auto修饰

>register 告诉编译器尽可能的让其修饰的变量驻留在寄存器中，不推荐使用

## 10.2 名字空间

>namespace 与class，struct，enum，union一样会把名字约束在一个独立的空间中

### 10.2.1 创建一个名字空间
```
namespace SpaceName{
	//Declarations
}
```
>namespace只能在全局范围内定义，可以互相嵌套

>结尾不用跟一个分号

>可以多个文件中用同一个namespace名字来定义

>可以用namespace定义别名: namespace a = xxxxxxxxxxxxxxxxxxx

>不能创建一个namespace的实例

#### 10.2.1.1 未命名的名字空间

>即省略 SpaceName， 标识在该编译单元内有效， 内部的变量及时不用static修饰也是内部链接

#### 10.2.1.2 友元

>名字空间中的类中声明的友元，自动成为该名字空间的成员

### 10.2.2 使用名字空间

>作用域运算符

>using指令引入所有的名字

>using声明一次性引用名字

#### 10.2.2.1 作用域解析

>::

#### 10.2.2.2 使用using指令

>using namespace SpaceName

>在一个名字空间中使用，该指定的名字空间会在该命名空间内有效

>在一个函数内使用，只会在该函数作用域内有效

>可以声明一个名字空间中的某一个具体的名字： using SpaceName::func

### 10.2.3 名字空间的使用

>头文件中推荐使用明确的限定，防止污染名字空间

## 10.3 C++中的静态成员

>类中的static修饰的变量被该类的所有对象共有，可以private，public，protect修饰

### 10.3.1 定义静态数据成员的存储

>类内的static成员，被所有的该类对象所共有，所以需要单独在类外定义。 type Class::name = value;

#### 10.3.1.1 静态数组的初始化
 
>与静态成员变量类似，静态数组在类内部只作为声明，还需要在类外部进行单独的定义，包括对象也是。

### 10.3.2 嵌套类和局部类

>静态变量定义在嵌套类中，只需要外部定义时多一层名字索引进行定义。

>静态变量不可以出现在局部类（函数中的类）中

### 10.3.3 静态成员函数

>静态成员函数属于类，可以由对象以-> . 进行调用，推荐使用 class::function 方式进行调用

>没有this指针，不可以使用非静态成员函数和非静态成员变量

>単例模式中，作为全局可用的唯一对象技巧。（需要特别注意构造函数应作为私有，包括拷贝构造函数）

## 10.4 静态初始化的相依性

>多个文件中因为编译顺序以及 static与extern结合使用，会导致一些编译依赖上的错误

### 10.4.1 怎么办

>避免使用

>所有的关键静态变量定义在一个文件中

>两种技术

>>1.定义一个专门类，使用计数的方式来构造依赖的静态变量

>>2.以构造顺序来控制，用函数内部定义static依赖的方式来进行控制

## 10.5 替代连接说明

>extern "C" {} 来说明以C语言的方式进行连接































