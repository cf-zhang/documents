# 第15章 多态性和虚函数

>多态性（在C++中通过虚函数来实现）是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征

>多态性提供了接口与具体实现之间的一层隔离

>封装通过组合特性和行为来生成新的数据类型

## 15.1 C++程序员的演变

>简单把C++当做一个更好的C

>进入基于对象的C++

>使用virtual

## 15.2 向上类型转换

>接口变窄，调用基类的方法

## 15.3 问题

>子类对象传入，调用的父类方法

### 15.3.1 函数调用捆绑

>早捆绑-编译前就对函数调用和函数体进行了捆绑

>晚捆绑、动态捆绑、运行时捆绑-在运行过程中根据运行时对象类型，将函数调用与函数体进行捆绑

## 15.4 虚函数

>为了引起晚捆绑，C++要求在基类中声明这个函数时使用virtual关键字

>只要基类中声明过virtual，其派生类无论是否再次使用virtual来声明，都是virtual特性

### 15.4.1 扩展性

>如果派生类中没有对virtual函数进行重写，那么后绑定行为会找到最近的一个被派生类中的定义进行调用

## 15.5 C++如何实现晚捆绑

>virtual告诉编译器它不应当执行早捆绑

>每个包含虚函数的类有一个虚函数表，还有一个虚函数表的指针

### 15.5.1 存放类型信息

>不管有几个虚函数，该类的长度会比正常的类多一个void指针的长度。

### １５.５.２　虚函数功能图示

>所有的VPTR都在对象的相同位置

>所有的虚函数表的顺序都是一致的，调用某个函数时会发生　VPTR+n来找到需要调用的函数

### 15.5.3 揭开面纱

```
push 1
push si #（si为寄存器，当前会存储this指针）
mov bx, word ptr [si]
call word ptr [bx+4] #(获取this指针即vtable的首地址，然后+4即得到一个特定函数体入口)
add sp,4 #（调用后返回）
```

### 15.5.4 安装vpointer

>就算是没有定义构造函数，编译器也会创建一个默认的构造函数用于初始化vptr

### 15.5.5 对象是不同的

>当基类引用或者指针定义的变量，其指向的对象可能是基类也可能是其派生类，所以这种情况会执行晚绑定

>当基类对象的时候，其执行的是早捆绑

## 15.6 为什么需要虚函数

>virtual会多占用函数寻址的部分性能，但是可以当性能至上的时候，可以考虑不使用virtual

>内联函数是不可能用于虚函数的，因为虚函数需要在虚表中存有函数指针

## 15.7 抽象基类和纯虚函数

>如果只想使用基类的接口，而不允许定义基类对象，那么可以将该类定义为纯虚函数

>纯虚函数声明 ： virtual type name()=0;

>当继承一个抽象类时，必须实现所有的虚函数，否则继承出的类也将是一个抽象类

>纯虚函数禁止对抽象类以传值方式调用，是为了防止对象切片

### 15.7.1 纯虚定义

>实际上基类的成员函数被声明为纯虚以后，仍然可以在类外进行该成员函数的函数体定义，做为基类调用的一块公共代码块，

>纯虚函数不可以在类定义括号内进行定义，因为这样定义出的函数实际上是内联函数，不存在函数地址。

## 15.8 继承和VTABLE

>派生类中会将基类中的vtable按顺序进行copy，如果派生类中又定义了自己的虚函数，那么会在这个表的后面进行追加

>派生类中新定义的虚函数，无法使用基类的引用或者指针来使用。如果想进行使用，那么需要进行乡下类型转化（RTTI）

### 15.8.1 对象切片

>不适用地址或者引用时的向上类型转换会造成切片

>对象切片：当拷贝一个对象到新的对象时，去掉原来对象的一部分

>因为调用重载按值传递

## 15.9 重载和重新定义

>派生类中不能改变基类中virtual函数的返回值类型

>派生类中重写基类中的一个重载成员函数，则在派生类中，其他的重载版本都将会被隐藏

>如果将上诉派生类进行向上类型转换，那么只有基类的重载函数们有效。

### 15.9.1 变量返回类型

>派生类中无法改变基类中virtual成员函数的返回值类型，

>如果这个返回值类型是可以进行上行转换的，那么可以接受该返回值类型的改变，但是不建议这么用

## 15.10 虚函数和构造函数

>编译器隐藏代码到我们的构造函数中，不仅初始化vptr，还检查this值，还有调用基类构造函数。

### 15.10.1 构造函数调用次序

>先基类构造，再成员对象构造，最后自身构造

>原则： 在进行构造函数的时候，应该保证其使用的所有内容都是已经定义过的。

### 15.10.2 虚函数在构造函数中的行为

>构造函数中调用一个虚函数，被调用的只是这个函数的本地版本，虚机制在构造函数中不工作

## 15.11 析构函数和虚析构函数

>构造函数是不能为虚函数的，但是析构函数能够且常常必须是虚的

>析构自最晚派生类开始，并向上到基类执行

>每个析构函数知道它所在的类从哪一个类派生而来，但是不知道从它派生出哪些类

>虚析构函数会从派生来析构->基类析构一直执行（反向执行）

### 15.11.1 纯虚析构函数

>要求纯虚析构函数必须有一个函数体。

>作用：使得基类是抽象类，不能定义对象

>不在派生类中对该析构函数进行重写也不会有问题，一样可以定义对象，因为有编译器默认生成的析构函数

### 15.11.2 析构函数中的虚机制

>与构造函数一致，析构函数中，只有成员函数的本地版本被调用，虚机制被忽略。基类中的析构不可能调用到派生类中的virtual函数

### 创建对象的继承

>容器类中，将所有的可容纳的元素继承自同一个基类，这样在进行析构的时候会由虚机制进行自动的调用各个级别的析构函数释放资源

## 15.12 运算符重载

>多重指派--多用于数学操作中，暂时未能理解

## 15.13 向下类型转换

>dynamic_cast显示类型转换是安全的乡下类型转换

>需要检测返回值是否为0来保证是否向下类型转换成功，即检测类型是否一致

>会消耗一些性能，当明确知道待转换的类型时，推荐使用static_cast来替代

>rtti机制中的typeid，配合static_cast

















































