# 第11章 引用和拷贝构造函数

>引用 是常量型指针，支持重载，为参数的传入传出提供便利

>拷贝构造函数 从现有对象中构造产生新对象

## 11.1 C++中的指针

>C中void*允许任意接受左值，和随意作为右值

>C++中强类型，不允许任意赋值，如果需要必须有类型转换

## 11.2 C++中的引用

>作为函数参数，也可以独立使用；

>>当引用创建时，必须被初始化

>>一个引用一旦和一个变量对应，那么不可以被改变该映射关系

>>不可以有NULL引用，必须和一个合法的存储空间关联

### 11.2.1 函数中的引用

>传入 可以改变外部对象的值，与指针作用类似

>返回 必须确保返回后该内存空间仍然有效

#### 11.2.1.1 常量引用

>常量引用可以接受变量和常量

>非常量引用只能接受变量，临时变量本质上都是常量

#### 11.2.1.2 指针引用

> int *&p;

### 11.2.2 参数传递准则

>引用传参更有效率

## 11.3 拷贝构造函数

>拷贝构造函数没有明确定义的时候会有默认生成

### 11.3.1 按值传递和返回

>一般来说参数是按照从右到左的方式进行压栈

#### 11.3.1.1 传递和返回大对象

>当自定义对象占用内存空间较大不可以存入寄存器的时候，会有编译器辅助函数来解决压栈问题

#### 11.3.1.2 函数调用栈框架

>函数参数-返回地址-局部变量

#### 11.3.1.3 重入

>为了支持中断，小的返回值一般直接由寄存器返回，大的返回值会直接在函数调用时传入要返回的内存位置，然后直接将

结果数据拷贝到该存储区

#### 11.3.1.4 位拷贝与初始化

>构造+1，析构-1最后结果不为0， C默认的按值传递会直接按位拷贝搞得鬼，C++会按默认拷贝构造函数处理

### 11.3.2 拷贝构造函数

>X(const X&) 按值传递对象时，会调用拷贝构造函数，按值返回对象时，也会拷贝构造函数

#### 11.3.2.1 临时对象

>调用返回类型为类的时候，如果不指定返回值赋值对象，那么会生产一个临时对象来完成创建-丢失

### 11.3.3 默认拷贝构造函数

>如果一个构造函数都没有，那么编译器会自动创建一个默认构造函数，如果存在任何一种构造函数，那么如果想使用

默认构造 函数，那么必须手动定义。

>组合的方式创建类，那么在该类的默认拷贝构造函数中，会递归调用所有的成员变量的拷贝构造函数（手工定义或自动生成的）

>尽量自己创建拷贝构造函数，让程序更加的可控。

### 11.3.4 替代拷贝构造函数的方法

>仅当准备用按值传递的方式构造类对象时，才会调用拷贝构造函数

#### 11.3.4.1 防止按值传递

>声明一个私有的拷贝构造函数

#### 11.3.4.2 改变外部对象的函数

>当需要改变外部对象时，考虑指针，或者非const的引用。

## 11.4 指向成员的指针

> int class::*ptr; ptr可以指向class内的任意一个int成员变量

> ptr = &class::intager; c.*ptr = 15;

### 11.4.1 函数

```
#include <iostream>
class Simple{
public:
	int f(float) const{return 1;}
};

int (Simple::*fp)(float) const;
int (Simple::*fp2)(float) const = &Simple::f;

int main() {
	fp = &Simple::f;
	return 0;
}

```














































