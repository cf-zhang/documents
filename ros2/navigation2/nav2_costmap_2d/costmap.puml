@startuml
'https://plantuml.com/class-diagram

namespace nav2_costmap_2d{
class ArrayParser{
-- public method --
vector<vector<float>> parseVVF(input, error_return);
}
enum CostValues{
NO_INFORMATION = 255,
LETHAL_OBSTACLE = 254,
INSCRIBED_INFLATED_OBSTACLE = 253,
FREE_SPACE = 0
}
class CollisionCheckerException{
-- public method --
explicit CollisionCheckerException(const std::string description)
}
class IllegalPoseException
{
-- public method --
IllegalPoseException(const std::string name, const std::string description)
-- protected data --
std::string name_;
}
CollisionCheckerException <-- IllegalPoseException
class CostmapMath{
inline double sign(double x)
inline double sign0(double x)
inline double distance(double x0, double y0, double x1, double y1)
double distanceToLine(pX, pY, x0, y0, x1, y1);
bool intersects(std::vector<Point> & polygon, float testx, float testy);
bool intersects(polygon1, polygon2);
}
class footprint{
void calculateMinAndMaxDistances(footprint, min_dist, max_dist);
geometry_msgs::msg::Point toPoint(geometry_msgs::msg::Point32 pt);
geometry_msgs::msg::Point32 toPoint32(geometry_msgs::msg::Point pt);
geometry_msgs::msg::Polygon toPolygon(std::vector<geometry_msgs::msg::Point> pts);
std::vector<geometry_msgs::msg::Point> toPointVector(:Polygon::SharedPtr polygon);
void transformFootprint(x,y,theta,footprint_spec,oriented_footprint);
void transformFootprint(x,y,theta,footprint_spec,oriented_footprint);
void padFootprint(std::vector<geometry_msgs::msg::Point> & footprint, double padding);
std::vector<geometry_msgs::msg::Point> makeFootprintFromRadius(double radius);
bool makeFootprintFromString(footprint_string,footprint);
}
class FootprintSubscriber{
-- public method --
FootprintSubscriber(node, topic_name, footprint_timeout);
FootprintSubscriber(node, topic_name, footprint_timeout);
FootprintSubscriber(node_base, node_topics, node_logging, node_clock, topic_name, footprint_timeout);
~FootprintSubscriber() {}
bool getFootprint(footprint, valid_footprint_timeout);
bool getFootprint(std::vector<geometry_msgs::msg::Point> & footprint);
bool getFootprint(footprint, stamp,  valid_footprint_timeout);
-- protected method --
void footprint_callback(const geometry_msgs::msg::PolygonStamped::SharedPtr msg);
-- protected data --
rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;
rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_;
rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_;
rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_;
void footprint_callback(const geometry_msgs::msg::PolygonStamped::SharedPtr msg);
std::string topic_name_;
bool footprint_received_{false};
rclcpp::Duration footprint_timeout_;
geometry_msgs::msg::PolygonStamped::SharedPtr footprint_;
rclcpp::Subscription<geometry_msgs::msg::PolygonStamped>::SharedPtr footprint_sub_;

}

class FootprintCollisionChecker<?CostmapT>{
-- public method --
FootprintCollisionChecker();
explicit FootprintCollisionChecker(CostmapT costmap);
double footprintCost(const Footprint footprint);
double footprintCostAtPose(double x, double y, double theta, const Footprint footprint);
double lineCost(int x0, int x1, int y0, int y1) const;
bool worldToMap(double wx, double wy, unsigned int & mx, unsigned int & my);
double pointCost(int x, int y) const;
void setCostmap(CostmapT costmap);

-- protected data --
CostmapT costmap_

}

class CostmapTopicCollisionChecker{
-- public method --
CostmapTopicCollisionChecker(costmap_sub,footprint_sub, tf, name, global_frame, robot_base_frame,transform_tolerance);
~CostmapTopicCollisionChecker()
double scorePose(const geometry_msgs::msg::Pose2D & pose);
bool isCollisionFree(const geometry_msgs::msg::Pose2D & pose);
-- protected method --
void unorientFootprint(const Footprint & oriented_footprint, Footprint & reset_footprint);
Footprint getFootprint(const geometry_msgs::msg::Pose2D & pose);
-- protected data --
std::string name_;
std::string global_frame_;
std::string robot_base_frame_;
tf2_ros::Buffer & tf_;
CostmapSubscriber & costmap_sub_;
FootprintSubscriber & footprint_sub_;
double transform_tolerance_;
FootprintCollisionChecker<std::shared_ptr<Costmap2D>> collision_checker_;
}
CostmapTopicCollisionChecker *-- CostmapSubscriber
CostmapTopicCollisionChecker *-- FootprintSubscriber
CostmapTopicCollisionChecker *-- FootprintCollisionChecker

class Costmap{

}
class MapLocation{
unsigned int x
unsigned int y
}
class MarkCell{
-- public method --
MarkCell(unsigned char * costmap, unsigned char value)
inline void operator()(unsigned int offset)
-- private data --
unsigned char * costmap_;
unsigned char value_;
}
class PolygonOutlineCells{
-- public: method --
PolygonOutlineCells(
inline void operator()(unsigned int offset)
-- private data --
const Costmap2D & costmap_;
std::vector<MapLocation> & cells_;
}

PolygonOutlineCells *-- Costmap2D
PolygonOutlineCells *-- MapLocation


class Costmap2D{
-- public method --
Costmap2D();
virtual ~Costmap2D();
unsigned char getCost(unsigned int mx, unsigned int my) const;
unsigned char getCost(unsigned int index) const;
void setCost(unsigned int mx, unsigned int my, unsigned char cost);
void mapToWorld(unsigned int mx, unsigned int my, double & wx, double & wy) const;
bool worldToMap(double wx, double wy, unsigned int & mx, unsigned int & my) const;
void worldToMapNoBounds(double wx, double wy, int & mx, int & my) const;
void worldToMapEnforceBounds(double wx, double wy, int & mx, int & my) const;
inline unsigned int getIndex(unsigned int mx, unsigned int my) const
inline void indexToCells(unsigned int index, unsigned int & mx, unsigned int & my) const
unsigned char * getCharMap() const;
unsigned int getSizeInCellsX() const;
unsigned int getSizeInCellsY() const;
double getSizeInMetersX() const;
double getSizeInMetersY() const;
double getOriginX() const;
double getOriginY() const;
double getResolution() const;
void setDefaultValue(unsigned char c)
unsigned char getDefaultValue()
bool setConvexPolygonCost()
void polygonOutlineCells()
void convexFillCells()
virtual void updateOrigin(double new_origin_x, double new_origin_y);
bool saveMap(std::string file_name);
void resizeMap()
void resetMap(unsigned int x0, unsigned int y0, unsigned int xn, unsigned int yn);
void resetMapToValue()
unsigned int cellDistance(double world_dist);
typedef std::recursive_mutex mutex_t;
mutex_t * getMutex()
-- protected method --
void copyMapRegion()
virtual void deleteMaps();
virtual void resetMaps();
virtual void initMaps(unsigned int size_x, unsigned int size_y);
inline void raytraceLine(at, x0, y0, x1, y1, max_length)

-- protected data --
unsigned int size_x_;
unsigned int size_y_;
double resolution_;
double origin_x_;
double origin_y_;
unsigned char * costmap_;
unsigned char default_value_;

-- private method --
inline void bresenham2D(at,abs_da,abs_db,error_b,offset_a,offset_b,offset,max_length)
-- private data --
mutex_t * access_;
}
Costmap2D *-- PolygonOutlineCells
Costmap2D *-- MarkCell
class Costmap2DROS{

}

class LayeredCostmap{
-- public method --
LayeredCostmap(std::string global_frame, bool rolling_window, bool track_unknown);
~LayeredCostmap();
void updateMap(double robot_x, double robot_y, double robot_yaw);
std::string getGlobalFrameID() const
void resizeMap(size_x, size_y, resolution, origin_x,origin_y, size_locked);
void getUpdatedBounds(double & minx, double & miny, double & maxx, double & maxy)
bool isCurrent();
Costmap2D * getCostmap()
bool isRolling()
bool isTrackingUnknown()
std::vector<std::shared_ptr<Layer>> * getPlugins()
void addPlugin(std::shared_ptr<Layer> plugin)
bool isSizeLocked()
void getBounds(unsigned int * x0, unsigned int * xn, unsigned int * y0, unsigned int * yn)
bool isInitialized()
void setFootprint(const std::vector<geometry_msgs::msg::Point> & footprint_spec);
const std::vector<geometry_msgs::msg::Point> & getFootprint() {return footprint_;}
double getCircumscribedRadius() {return circumscribed_radius_;}
double getInscribedRadius() {return inscribed_radius_;}
bool isOutofBounds(double robot_x, double robot_y);
-- private data --
Costmap2D costmap_;
std::string global_frame_;
bool rolling_window_;
bool current_;
double minx_, miny_, maxx_, maxy_;
unsigned int bx0_, bxn_, by0_, byn_;
std::vector<std::shared_ptr<Layer>> plugins_;
bool initialized_;
bool size_locked_;
double circumscribed_radius_, inscribed_radius_;
std::vector<geometry_msgs::msg::Point> footprint_;
}
LayeredCostmap *-- Costmap2D
LayeredCostmap o-- Layer

class Layer{
-- public method --
Layer();
virtual ~Layer() {}
void initialize(parent, name, tf, node, client_node, rclcpp_node);
virtual void deactivate()
virtual void activate()
virtual void reset()
virtual void updateBounds(robot_x,robot_y,robot_yaw,min_x,min_y,max_x,max_y);
virtual void updateCosts(master_grid,min_i,min_j,max_i,max_j) = 0;
virtual void matchSize() {}
virtual void onFootprintChanged() {}
std::string getName() const
bool isCurrent() const
const std::vector<geometry_msgs::msg::Point> & getFootprint() const;
void declareParameter(const std::string & param_name, const rclcpp::ParameterValue & value);
bool hasParameter(const std::string & param_name);
void undeclareAllParameters();
std::string getFullName(const std::string & param_name);
-- protected method --
virtual void onInitialize() {}

-- protected data --
LayeredCostmap * layered_costmap_;
std::string name_;
tf2_ros::Buffer * tf_;
nav2_util::LifecycleNode::SharedPtr node_;
rclcpp::Node::SharedPtr client_node_;
rclcpp::Node::SharedPtr rclcpp_node_;
bool current_;
bool enabled_;
std::unordered_set<std::string> local_params_;
-- private data --
std::vector<geometry_msgs::msg::Point> footprint_spec_;
}
Layer *-- LayeredCostmap

Class CostmapSubscriber{
-- public method --
CostmapSubscriber(node, topic_name);
CostmapSubscriber(node, topic_name);
CostmapSubscriber(node_base, node_topics, node_logging, topic_name);
~CostmapSubscriber()
std::shared_ptr<Costmap2D> getCostmap();
-- protected method --
void toCostmap2D();
void costmapCallback(const nav2_msgs::msg::Costmap::SharedPtr msg);
-- protected data --
rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;
rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_;
rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_;
std::shared_ptr<Costmap2D> costmap_;
nav2_msgs::msg::Costmap::SharedPtr costmap_msg_;
std::string topic_name_;
bool costmap_received_{false};
rclcpp::Subscription<nav2_msgs::msg::Costmap>::SharedPtr costmap_sub_;
}
CostmapSubscriber *-- Costmap

class ClearCostmapService{
-- public method --
ClearCostmapService(node, costmap);
ClearCostmapService() = delete;
void clearExceptRegion(double reset_distance);
void clearAroundRobot( window_size_x, window_size_y);
void clearEntirely();

-- private method --
void clearExceptRegionCallback(request_header, request, response);
void clearAroundRobotCallback(request_header, request, response);
void clearEntireCallback(request_header, request, response);
void clearLayerExceptRegion(costmap, pose_x, pose_y, reset_distance);
bool isClearable(const std::string & layer_name) const;
bool getPosition(double & x, double & y) const;
std::string getLayerName(const Layer & layer) const;
-- private data --
nav2_util::LifecycleNode::SharedPtr node_;
Costmap2DROS & costmap_;
unsigned char reset_value_;
std::vector<std::string> clearable_layers_;
Service<ClearCostmapExceptRegion> clear_except_service_;
Service<ClearCostmapAroundRobot>::SharedPtr clear_around_service_;
Service<ClearEntireCostmap>::SharedPtr clear_entire_service_;
}

class Costmap2DPublisher{
-- public method --
Costmap2DPublisher(ros_node,costmap,global_frame,topic_name,always_send_full_costmap);
~Costmap2DPublisher();
void on_configure()
void on_activate()
void on_deactivate()
void on_cleanup() {}
void updateBounds(x0,xn,y0,yn)
void publishCostmap();
bool active()
-- private method --
void prepareGrid();
void prepareCostmap();
void costmap_service_callback( request_header, request, response);
-- private data --
nav2_util::LifecycleNode::SharedPtr node_;
Costmap2D * costmap_;
std::string global_frame_;
std::string topic_name_;
unsigned int x0_, xn_, y0_, yn_;
double saved_origin_x_;
double saved_origin_y_;
bool active_;
bool always_send_full_costmap_;
LifecyclePublisher<OccupancyGrid>::SharedPtr costmap_pub_;
LifecyclePublisher<OccupancyGridUpdate> costmap_update_pub_;
LifecyclePublisher<Costmap>::SharedPtr costmap_raw_pub_;
Service<GetCostmap>::SharedPtr costmap_service_;
float grid_resolution;
unsigned int grid_width, grid_height;
std::unique_ptr<nav_msgs::msg::OccupancyGrid> grid_;
std::unique_ptr<nav2_msgs::msg::Costmap> costmap_raw_;
static char * cost_translation_table_;
}

ClearCostmapService *-- Costmap2DROS
Costmap2DPublisher *-- Costmap2D
Costmap2DPublisher *-- Costmap
}
std.runtime_error <-- nav2_costmap_2d.CollisionCheckerException
@enduml